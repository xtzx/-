> 本文继续之前对JS引用类型、基本类型的差异引申出对内存空间的分析。

## 内存空间与执行上下文：

首先在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

最上层是代码空间，存储代码转换后的机器码信息，中间是栈空间，存储声明的基本类型，最下层是堆空间，存储代码中使用到的对象。

首先宏观上来讲，JS的执行是通过一个个的Task驱动浏览器的，就JS解释器层面来说，代码执行在执行上下文上。

执行上下文是代码运行中真实存在于内存中的，相比较之下作用域只是一套约束规范。

执行上下文中包含变量环境、词法环境、this binding和Scope Chain，创建阶段中就包含到预解析变量提升相关，等到执行阶段会通过词法作用域规则和动态作用域规则确定相应的变量和this值。

简单来讲，作用域、VO、AO都只是抽象的规范，执行上下文才是其具体综合实现。

首先代码执行在一个全局执行上下文中，每次函数执行都会新建执行上下文，执行完毕就会切换新的执行上下文，浏览器会周期性销毁不占用的内存空间，其中就包括不再使用的执行上下文。

所有的执行上下文都存在一个执行上下文栈中，这个栈就保存在内存空间的栈空间中。

## 堆栈内存差异

栈空间中内存分配都是连续的，分配的时候都会确定相应的偏移量，这样的好处是大小固定，可以迅速查找到某一处具体值，同样对于空间利用也更加充分不会有碎片化空间。但是正是因为栈内的有效数据通常是连续存储的所以不利于管理大内存，尤其是JS对这种动态性语言。总之，栈的好处是：方便、快、有效避免内存碎片化。

因为栈不利于动态地管理并且有效地利用宝贵的内存资源。于是产生了堆。堆中可以存放大小不固定的变量，但是这样的问题是慢、产生内存碎片。由于高级语言不需要主动操作内存所以不再赘述其他差异。

JS中最重要的就是函数，函数是执行在函数执行上下文上的，每次执行函数都会新建新的函数执行上下文所以需要JavaScript 引擎在函数执行栈中一直切换函数执行上下文。正是因为栈的特性导致这个切换操作非常快。但是如果将所有数据都存放在栈的话，会导致内存偏移量不再固定进而导致切换速度降低、函数执行变慢、程序变慢。

所以，通常来讲，栈空间都不会设置非常大，仅仅存放一些原始类型的小数据。而对于对象这种占用空间很大的数据都会被存放在堆中，因为堆很大，但是缺点就是分配内存和回收会比较慢，占用时间久。


因本人实力有限难免有错误或者表达不全，欢迎讨论指正。